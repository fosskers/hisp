; Hisp Prelude

;; MATH
(define sum (ns) (foldlH + 0 (ns)))

(define product (ns) (foldlH * 1 (ns)))

(define square (n) (^ (n) 2))

(define cube (n) (^ (n) 3))

; What about `0`?
(define even? (n) (zero? (mod (n) 2)))

(define odd? (n) (not (even? (n))))

(define pos? (n) (> (n) 0))

(define neg? (n) (< (n) 0))

(define zero? (n) (= 0 (n)))

(define divides? (a b) (= 0 (mod (a) (b))))

(define prime? (n)
        (cond (< (n) 2) False
              (= (n) 2) True
              (else)    (prime-work (n) (: 2 (range-step 3 5 (+ 1 (sqrt (n))))))))

(define prime-work (n divs)
        (cond (null? (divs)) True
              (divides? (n) (head (divs))) False
              (else) (prime-work (n) (tail (divs)))))

;; LISTS
; `rangeH` is must faster.
(define range (a b) (if (= (a) (b))
                        ((a))
                        (: (a) (range (+ 1 (a)) (b)))))

(define range-step (a b c) (range-step' (a) (- (b) (a)) (c)))

; Need closures...
(define range-step' (a s c) (if (> (a) (c))
                                ()
                                (: (a) (range-step' (+ (s) (a)) (s) (c)))))

(define null? (l) (= 0 (len (l))))

(define single? (l) (= 1 (len (l))))

(define map (f l) (if (null? (l))
                      ()
                      (: ((f) (head (l)))
                         (map (f) (tail (l))))))

(define filter (p l)
   (if (null? (l))
       ()
       (if ((p) (head (l)))
           (: (head (l)) (filter (p) (tail (l))))
           (filter (p) (tail (l))))))

; Iterative, so better? Tail-recursable?
(define foldl (f z l)
        (if (null? (l))
            (z)
            (foldl (f)
                   ((f) (z) (head (l)))
                   (tail (l)))))

(define foldr (f z l)
        (if (null? (l))
            (z)
            ((f) (head (l))
                 (foldr (f)
                        (z)
                        (tail (l))))))

;; OTHER
; Function Composition
; Doesn't seem like lexical closures work...
(define . (f g) (lambda (a) ((f) ((g) (a)))))

(define not (p) (if (p) False True))

(define id (n) (n))

(define $ (f a) ((f) (a)))

(define and? (l) (cond (null? (l)) True
                       (not (head (l))) False
                       (else) (and? (tail (l)))))

(define or? (l) (cond (null? (l)) False
                      (head (l)) True
                      (else) (or? (tail (l)))))
